<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>My Test</title>
</head>
<body>
    <a>Some Link
        <div><img src="http://127.0.0.1:5000/uploads/29.gif" /></div>
    </a>

    <div class="container">
        <div class="section">
            <div class="chartArea" id="target">

            </div>
        </div>
    </div>

    <style>
        html{
            touch-action: none;
        }
        a>div { display: none; }
        a:hover>div { display: block; }

        .hover:hover{ background-color: yellow;}

        text {
          font-family: sans-serif;
          font-size: 7pt;
        }
        svg{
            border: 1px solid black;
            margin: auto;
        }
        rect{
            margin: auto;
        }
    </style>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>
        let rawdata;
        fetch(`/xydata`).then(function(response){
            return response.json();
        }).then(function(json){
            rawdata = json;
            console.log(rawdata);

            const width = 1000;
            const height = 1000;
            const chartArea = d3.select(".container");
            const svg = chartArea
            .selectAll("#target")
            .append("svg")
            .style("width", width)
            .style("height", height);

            const opacity_scale_label = d3.scaleLinear().domain([6,8]).range([0,1]).clamp(true)
            const opacity_scale_dots = d3.scaleLinear().domain([1,6]).range([0.4,1]).clamp(true)


            // var randomX = d3.randomNormal(width / 2, 80),
            // randomY = d3.randomNormal(height / 2, 80),
            // data = d3.range(200).map(function() {
            //     return [randomX(), randomY()];
            // });

            function build_graph(data){
                // const graph = [];
                const graph = {
                    positions:[],
                    svgs:[],
                    nodes:[]
                };
                for (let index = 0; index < data.length; index++) {
                    const element = data[index];
                    // graph.push({
                    //     position: [element.x, element.y],
                    //     svg: element.svg
                    // })
                    graph.positions.push([element.x, element.y])
                    graph.svgs.push(element.svg)
                    graph.nodes.push({
                        x:element.x,
                        y:element.y,
                        svg: element.svg
                    })
                }
                // console.log(graph.positions);
                // console.log(graph.svgs);
                return graph;
            }

            data = build_graph(rawdata);

            const circle = svg
            .selectAll("circle")
            .data(data.positions)
            .join("circle")
            .attr("r", 3)
            .style("fill", "black")
            .style("opacity", opacity_scale_dots(1))
            .attr("transform", transform(d3.zoomIdentity));
        //     .html(function (d) {
        //     return d.svg;
        // });

            // const hovers = svg
            // .selectAll("hover")
            // .data(data)
            // .enter()
            // .append("g")
            // .html(function(d){
            //     return d.svg;
            // });

            var node = svg
            .append("g")
            .selectAll(".node")
            .data(data.nodes)
            .enter()
            .append("g")
            .html(function (d) {
                return d.svg;
            });

            const hypers = svg
            .selectAll("hyper")
            .data(data.positions)
            .join("g")
            .attr("transform", transform(d3.zoomIdentity))
            .html("<g class='hover'><a href='http://127.0.0.1:5000/tree/30'><image style='overflow:visible;' xlink:href='http://127.0.0.1:5000/uploads/29.gif'></image></g><text>Car34</text></a></g>");

            const format = d3.format('.0f');
            const labels = svg
            .selectAll("text")
            .data(data.positions)
            .join("text")
            .attr("x", 4)
            .attr("y", 3)
            .style("fill", "darkgray")
            .attr("transform", transform(d3.zoomIdentity))
            .style("display","none")
            .text(d => d.map(format).join("/"));

            svg
            .append("rect")
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .attr("width", width)
            .attr("height", height)
            .call(
            d3
                .zoom()
                .scaleExtent([1, 10])
                .on("zoom", zoom)
            );


            function zoom(event) {
                const cop = opacity_scale_dots(event.transform.k);
            
                circle
                .attr("transform", transform(event.transform))
                .style("opacity", cop);
                
                const k = event.transform.k;
                if (k < 6){
                labels.style('display','none');
                }else{
                const op = opacity_scale_label(k);
                labels.attr("transform", transform(event.transform))
                .style('display', null)
                .style('opacity', op);
                }
                // console.log(event.transform.k);
            }

            function transform(t) {
                return function(d) {
                    return "translate(" + t.apply(d) + ")";
                };
            }
        })

        // const width = 1000;
        // const height = 1000;
        // const chartArea = d3.select(".container");
        // const svg = chartArea
        // .selectAll("#target")
        // .append("svg")
        // .style("width", width)
        // .style("height", height);

        // const opacity_scale_label = d3.scaleLinear().domain([6,8]).range([0,1]).clamp(true)
        // const opacity_scale_dots = d3.scaleLinear().domain([1,6]).range([0.4,1]).clamp(true)


        // // var randomX = d3.randomNormal(width / 2, 80),
        // // randomY = d3.randomNormal(height / 2, 80),
        // // data = d3.range(200).map(function() {
        // //     return [randomX(), randomY()];
        // // });

        // function build_graph(data){
        //     const graph = {
        //         positions:[],
        //         svgs:[],
        //     };
        //     for (let index = 0; index < data.length; index++) {
        //         const element = data[index];
        //         graph.positions.push([element.x, element.y])
        //         graph.svgs.push(element.svg)
        //     }
        //     console.log(graph.positions);
        //     console.log(graph.svgs);
        //     return graph;
        // }

        // data = build_graph(rawdata);

        // const circle = svg
        // .selectAll("circle")
        // .data(data)
        // .join("circle")
        // .attr("r", 3)
        // .style("fill", "black")
        // .style("opacity", opacity_scale_dots(1))
        // .attr("transform", transform(d3.zoomIdentity));

        // const format = d3.format('.0f');
        // const labels = svg
        // .selectAll("text")
        // .data(data)
        // .join("text")
        // .attr("x", 4)
        // .attr("y", 3)
        // .style("fill", "darkgray")
        // .attr("transform", transform(d3.zoomIdentity))
        // .style("display","none")
        // .text(d => d.map(format).join("/"));

        // svg
        // .append("rect")
        // .attr("fill", "none")
        // .attr("pointer-events", "all")
        // .attr("width", width)
        // .attr("height", height)
        // .call(
        // d3
        //     .zoom()
        //     .scaleExtent([1, 10])
        //     .on("zoom", zoom)
        // );


        // function zoom(event) {
        //     const cop = opacity_scale_dots(event.transform.k);
        
        //     circle
        //     .attr("transform", transform(event.transform))
        //     .style("opacity", cop);
            
        //     const k = event.transform.k;
        //     if (k < 6){
        //     labels.style('display','none');
        //     }else{
        //     const op = opacity_scale_label(k);
        //     labels.attr("transform", transform(event.transform))
        //     .style('display', null)
        //     .style('opacity', op);
        //     }
        //     // console.log(event.transform.k);
        // }

        // function transform(t) {
        //     return function(d) {
        //         return "translate(" + t.apply(d) + ")";
        //     };
        // }

        // chart = svg.node();
    </script>
    
   </body>
</html>