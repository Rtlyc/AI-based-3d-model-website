<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>My Test</title>
</head>

<body>
    <div class="container">
        <div class="section">
            <div class="chartArea" id="target">

            </div>
        </div>
    </div>

    <style>
        html {
            touch-action: none;
        }

        text {
            font-family: sans-serif;
            font-size: 7pt;
        }

        svg {
            border: 1px solid black;
            margin: auto;
        }

        rect {
            margin: auto;
        }
    </style>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="http://threejs.org/build/three.min.js"></script>
    <script>

    (async function(){

    // const url = document.URL;
    // const startind = url.lastIndexOf('/')+1
    // let id = document.URL.substring(startind,url.length);

    let data;
    let id = 49993;
    var response = await 
    fetch(`/neighbors/${id}`).then(function(response){
        return response.json();
    }).then(function(json){
        data = json;
    })
    console.log(data)})()
    

        // const viz_height = 667.8;
        // const points_radius = 30;
        // const width = 1000;
        // const height = 1000;
        // const chartArea = d3.select(".container");
        // const svg = chartArea
        //     .selectAll("#target")
        //     .append("svg")
        //     .style("width", width)
        //     .style("height", height);
        // const g = svg.append("g");
        // const camera = new THREE.PerspectiveCamera(90, width / viz_height, 1, 1000);
        // const renderer = new THREE.WebGLRenderer({ antialias: true, g });
        // renderer.setSize(width, viz_height);
        // renderer.setPixelRatio(devicePixelRatio);

        // function zoomEvent(zoom) {
        //     let canvas_inputs = {}
        //     const scale = zoom.k;
        //     camera.position.x = -(zoom.x - width / 2) / scale;
        //     camera.position.y = (zoom.y - viz_height / 2) / scale;
        //     camera.position.z = get_camera_z(Math.log(scale));
        //     camera.fov = needed_fov(viz_height, camera.position.z, scale)

        //     // future compatibility
        //     camera.near_plane = 1//camera.position.z * 2 // + near_year/1000
        //     camera.far_plane = 10000//camera.position.z / 2//camera.position.z + far_year/1000

        //     camera.updateProjectionMatrix()
        //     renderer.render(scene, camera);

        //     canvas_inputs.k = scale
        //     canvas_inputs.x = camera.position.x
        //     canvas_inputs.y = camera.position.y
        //     canvas_inputs.z = camera.position.z
        //     canvas_inputs.fov = camera.fov
        //     canvas_inputs.near_plane = camera.near_plane
        //     canvas_inputs.far_plane = camera.far_plane

        //     drawCamera(canvas_inputs)

        //     return canvas_inputs
        // }

        // const point_size = 2;
        // const point_size_adjuster = 0.85;
        // pointsMaterial = new THREE.PointsMaterial({
        //     size: point_size * point_size_adjuster,
        //     sizeAttenuation: 
        // })
        // {
        //     let point_size_adjuster = 1
        //     if (binary == "Semantic zoom") {
        //         point_size_adjuster = 2
        //     } else if (binary == "Geometric zoom") {
        //         point_size_adjuster = 0.25 
        //     } else if (binary == "Balanced zoom") {
        //         point_size_adjuster = 0.85 
        //     }
        //     return new THREE.PointsMaterial({
        //         size: point_size * point_size_adjuster,
        //         sizeAttenuation: sizeAttenuation,
        //         vertexColors: THREE.VertexColors,
        //         map: circle_sprite,
        //         transparent: true
        //     })
        //     }
    </script>

</body>

</html>